import { promises as fs } from 'node:fs';
import path from 'node:path';
import { fileURLToPath } from 'node:url';

type SkillExportRef = {
    fileBase: string;
    exportName: string;
    skillId?: string;
};

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);
const engineRoot = path.resolve(__dirname, '..');
const skillsDir = path.join(engineRoot, 'src', 'skills');
const generatedDir = path.join(engineRoot, 'src', 'generated');
const generatedFile = path.join(generatedDir, 'skill-registry.generated.ts');
const manualRegistryFile = path.join(engineRoot, 'src', 'skillRegistry.ts');

const extractObjectKeyOrder = (source: string, objectName: string): string[] => {
    const objectMatch = source.match(new RegExp(`(?:export\\s+const|const)\\s+${objectName}\\s*=\\s*\\{([\\s\\S]*?)\\};`));
    if (!objectMatch) return [];
    const body = objectMatch[1];
    const keys: string[] = [];
    for (const line of body.split(/\r?\n/)) {
        const trimmed = line.trim();
        if (!trimmed || trimmed.startsWith('//')) continue;
        const m = trimmed.match(/^([A-Za-z0-9_]+)\s*,?$/);
        if (m) keys.push(m[1]);
    }
    return keys;
};

const extractSkillExportsFromSource = (source: string): Array<{ exportName: string; skillId?: string }> => {
    const refs: Array<{ exportName: string; skillId?: string }> = [];
    const exportRegex = /export\s+const\s+([A-Z0-9_]+)\s*:\s*SkillDefinition\s*=/g;
    let match: RegExpExecArray | null;
    while ((match = exportRegex.exec(source)) !== null) {
        const exportName = match[1];
        const tail = source.slice(match.index, match.index + 800);
        const idMatch = tail.match(/\bid\s*:\s*['"]([A-Z0-9_]+)['"]/);
        refs.push({ exportName, skillId: idMatch?.[1] });
    }
    return refs;
};

const loadPreferredOrder = async (): Promise<string[]> => {
    try {
        const generated = await fs.readFile(generatedFile, 'utf8');
        const order = extractObjectKeyOrder(generated, 'GENERATED_COMPOSITIONAL_SKILLS');
        if (order.length > 0) return order;
    } catch {
        // fall through to manual registry
    }

    try {
        const manual = await fs.readFile(manualRegistryFile, 'utf8');
        return extractObjectKeyOrder(manual, 'COMPOSITIONAL_SKILLS');
    } catch {
        return [];
    }
};

const collectSkillExports = async (): Promise<SkillExportRef[]> => {
    const dirEntries = await fs.readdir(skillsDir, { withFileTypes: true });
    const files = dirEntries
        .filter(entry => entry.isFile() && entry.name.endsWith('.ts') && !entry.name.endsWith('.d.ts'))
        .map(entry => entry.name)
        .sort((a, b) => a.localeCompare(b));

    const refs: SkillExportRef[] = [];
    const seenExportNames = new Set<string>();
    const seenSkillIds = new Set<string>();

    for (const fileName of files) {
        const fileBase = fileName.replace(/\.ts$/, '');
        const absPath = path.join(skillsDir, fileName);
        const source = await fs.readFile(absPath, 'utf8');
        const exports = extractSkillExportsFromSource(source);
        if (exports.length === 0) continue;

        for (const { exportName, skillId } of exports) {
            if (seenExportNames.has(exportName)) {
                throw new Error(`Duplicate skill export name detected: ${exportName}`);
            }
            if (skillId && seenSkillIds.has(skillId)) {
                throw new Error(`Duplicate skill id detected: ${skillId}`);
            }

            seenExportNames.add(exportName);
            if (skillId) seenSkillIds.add(skillId);
            refs.push({ fileBase, exportName, skillId });
        }
    }

    return refs;
};

const sortRefs = (refs: SkillExportRef[], preferredOrder: string[]): SkillExportRef[] => {
    const priority = new Map<string, number>();
    preferredOrder.forEach((name, idx) => priority.set(name, idx));

    return [...refs].sort((a, b) => {
        const pa = priority.get(a.exportName);
        const pb = priority.get(b.exportName);
        if (pa != null && pb != null) return pa - pb;
        if (pa != null) return -1;
        if (pb != null) return 1;
        return a.exportName.localeCompare(b.exportName);
    });
};

const renderGeneratedFile = (refs: SkillExportRef[]): string => {
    const importLines = refs.map(ref => `import { ${ref.exportName} } from '../skills/${ref.fileBase}';`);
    const objectLines = refs.map(ref => `    ${ref.exportName},`);
    const skillIds = refs.map(ref => ref.skillId || '?').join(', ');

    return `/**
 * AUTO-GENERATED FILE. DO NOT EDIT.
 * Generated by: packages/engine/scripts/generateSkillRegistry.ts
 * Skills discovered: ${refs.length} (${skillIds})
 */
import type { SkillDefinition } from '../types';
${importLines.join('\n')}

export const GENERATED_COMPOSITIONAL_SKILLS = {
${objectLines.join('\n')}
} satisfies Record<string, SkillDefinition>;
`;
};

const main = async () => {
    const refs = await collectSkillExports();
    const preferredOrder = await loadPreferredOrder();
    const sortedRefs = sortRefs(refs, preferredOrder);
    const content = renderGeneratedFile(sortedRefs);

    await fs.mkdir(generatedDir, { recursive: true });
    await fs.writeFile(generatedFile, content, 'utf8');

    console.log(`Generated ${path.relative(engineRoot, generatedFile)} with ${sortedRefs.length} skills.`);
};

main().catch(err => {
    console.error(err);
    process.exitCode = 1;
});
